一、初始知识
	1、对象是占用实际存储空间的，而类型并不占实际存储空间
	2、宏定义是在预编译的时候进行“字符置换”，不是变量，没有类型，不占用存储空间；
	const具有变量的属性，有数据类型，占用存储单元，有地址，可以用指针指向它
	3、函数重载要求参数个数或者参数类型必需不能一样
	4、函数模块：template<typename T1,class T2>
	5、默认参数的函数：int fun(int a = 10);,运行时，实参与形参的结合是从左到右的，所有默认参数要放在最后面
	6、一个函数不能既作为重载函数，又作为默认参数的函数，因为编译器不知道找谁
	7、引用：别名，不开辟存储空间，声明时必须指定它代表的是哪个变量，如int &b = a;
	8、内置函数：inline编译时将代码嵌入到主函数中，inline void display();
	9、字符串：只包括字符串本身的字符而不包括"\0",sizeof(str) == 4,因为str只是存放相应字符串的地址。有“= == != > <”等运算，也可通过下标操作某一字符，如str[0] = 'a'
	
二、类和对象
	1、多态：由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应
	2、类不占用空间，而对象占用存储空间
	3、类的声明class A{};,成员不声明权限，默认是private
	4、可以在声明类的同时声明对象，如class A{}a,b;
	5、可以用struct声明类（为了兼容C），方法和class一样，但默认是public权限
	6、访问全局变量（如果全局有个变量或者函数和类相同），可通过::a，::display()调用全局变量
	7、inline成员函数：类内定义的函数默认是inline的,不用再声明inline，类外定义时，可在声明或者定义时加上inline即可（可二选一或者两个都写）
	8、一个对象所占用的存储空间大小只取决于该对象中数据成员所占的空间，与成员函数无关
	9、对象的成员在没定义时，其值是不可预知的。可用函数引用+默认参数的方法进行初始化，如void setDefault(A&, int hour = 0, int min = 0; int second = 0);
	10、编译时，cpp文件会将#include "xxx.h"的内容替换成相应头文件的内容，然后进行编译，生成xx.obj文件，最后再将多个obj链接成可执行文件。
		所以，如果在类内定义了函数，则会被多次编译
		
三、关于类和对象的进一步讨论
	1、默认构造函数
	2、带参构造函数
	3、用参数初始化表对数据成员进行初始化，如Box::Box(int w, int h, int l):height(h),width(w),len(l){}
	4、构造函数重载
	5、使用默认参数的构造函数
	6、析构函数（只能有一个，不可重载）
	7、指向成员函数的指针：指针要求1、参数类型和个数一致 2、返回值类型一致 3、所属类一致
		故不能用void (*p)()指向，要用void(Time::*p)()指向，调用要（t1.*p）();   ---好麻烦啊
	8、常对象：const Time t;或者Time const t;  不能调用该对象的非const成员函数
	9、常数据成员：如const int hour;  不能在构造函数里赋值，需要用初始化参数列表形式赋初值Time::Time(int h):hour(h){}
	9、常成员函数：void display() const;可以引用本类中的数据，但不能修改
	10、指向对象的常指针：Time* const ptr = new Time(); --指针始终保持为初值，但可以改变其所指向对象中数据成员的值
	11、常对象指针：const Time* ptr = &t1;  --不能通过常对象指针修改成员数据，如（*ptr）.hour = 2; ,但可以通过对象修改，如t1.hour = 4;
	12、对象的常引用：void fun(const Time& t);
	13、对象的赋值，用“=”进行赋值，只对数据的成员赋值，类的成员不能包括动态分配的数据，否则会出现严重的后果 Box box2 = box1;
	14、对象的复制：复制构造函数Box box2(box1);
	15、函数参数列表包含对象时，会调用复制构造函数生成一个新的对象传入到函数中；函数返回值是对象时，在返回时，会调用复制构造函数返回一个新的对象给调用者而不是函数内定义的对象
		Box fun(){Box box(1,2,3); return box;}	//并不是返回box，而是返回一个tempbox;
	16、静态数据成员：类所有，所有对象共用。当一个对象修改时，另一个对象获取到的值也是变的。静态数据成员只能在类体外进行初始化
	17、友元函数：可以访问类中的私有成员。friend void display(Box& box); frined void Time::display(Box&);
	18、友元类： frined Time;
	19、类模板：
		声明
		template <class T> 
		class A{
			public:
			A(T a);
		};
		定义
		A <int> a(5);
		在类外定义不能定义成 T A::A(T a){}, 要定义成:
		template <class T> 
		T A<T>::A(T a){}
		
四、运算符重载（实质是函数重载）
	1、格式：函数类型 operator 运算符名称（形参列表） 如：Complex operator+ (Complex&, Complex&);（把“operator+”认为是一个函数即可）
	2、++，--如果形参没有int，则是前置，在int则是后置，如Time operator++(int)为 time++; Time operator++()为++time;
	3、输入、输出流重载：(必需声明为友元函数)
		friend istream& operator>> (istream&, Time&)
		friend ostream& operator<< (ostream&, Time&)
	
	4、类型转换：“类型名（数据）”或者 “数据（类型名）”，如int(10)、10(int)
	5、转换构造函数：Complex(float)
	6、类型转换函数：格式“operator 类型()”,如：operator double()
	7、在执行 double+Complex时,运行时，会检测有无运算符“+”重载函数，若没有，再检测有无类型转换函数，再检测有没转换构造函数
		如 double1+complex, 先检测有无重载“+”,有则执行，没有则检测complex有没有类型转换成double的
		complex+double1,先检测有无重载“+”，有重载但没有相关重载，会检测double1有没有Complx类型的转换构造函数。

五、继承与派生	
	1、在派生类初始化基类：Student1(int a, int b):Student(a){},也可以用这种方法初始化子类成员Student1(int a, int b):Student(a)，stu(a){}
	2、派生时，先构造基类再构造派生类，析构时，先析构派生类再析构基类（遵循先构造的后析构）
	3、派生时，派生类同名函数会覆盖基类的同名函数，如果想调用基类的同名函数，可以像Strudent::display()一样调用
	4、二义性：多重继承的多个基类有同一个函数，可以通过作用域解决，如c.A::display(),c.B::display()
	5、虚基类：派生时，派生类会保存基类的成员函数，如果多个基类又继承共同的基类，则会有多个基类的成员函数。而虚基类只会保存一份共同基类的成员成员
		class B:virtual public A,class C:virtual public A, class D:public B,public C
		但要在最后的派生类对基类进行初始化 D(int a, int b, int c):A(a),B(b),C(c){}
	6、派生类可以基类赋值，如A a = B();但a调用的方法只会调用到A的相应方法而不会调用到B的，如：解决办法是通过虚函数
		class A{ void display()}; 
		class B:public A{
			void display(){
				A::display()
				...
			}
		};
	
六、多态性与虚函数
	1、多态：具有不同功能的函数可以用同一个函数名
	2、静态多态：编译时系统就是决定调用的是哪个函数（函数重载）;动态多态：程序运行时才动态地确定（虚函数）
	3、虚函数：允许在派生类中重新定义与基类同名的函数，并且通过基类指针或引用来访问基类和派生类中的同名方法
	4、普通的继承和派生，当基类指针被赋值为派生类时，会进行强制转换为基类的指针。所以基类指针基类指向的是派生类中基类部分;
		而虚函数实现了在派生类的基类部分，派生类的虚函数取代了基类原来的虚函数。所以基类指针指向派生类时，调用虚函数时，是调用派生类的虚函数
	5、当一个成员函数被声明为虚函数后，其派生类中的同名函数自动成为虚函数，可以不用声明virtual，但习惯声明为virtual，以表示这是个虚函数
	6、如果派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数
	7、虚析构函数：当用new 一个派生类并赋值为一个基类指针时，在通过delete销毁对象时，只会执行派生类的析构方法而没有执行基类的析构方法，但在构造时，
		却基类和派生类的构造方法都被执行。此时，可以将基类析构函数声明了虚函数（派生类的析构函数会继承，也是虚函数，只是名字不一样），在执行析构时，
		就可以析构基类和派生类了。（习惯上将基类的析构方法都声明了虚函数）
	8、纯虚函数：声明虚函数时被“初始化”为0的函数
	9、抽象类：包含纯虚函数的类都是抽象类。派生类中没有对所有纯虚函数进行定义，则此派生类仍然是抽象类
	

七、输入输出流

八、C++工具
	1、异常处理
	2、命令空间：由用户命名的作用域，用来处理程序中常见的同名冲突































